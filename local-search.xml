<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>软件测试复习纲要</title>
    <link href="/2022/06/09/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%A4%8D%E4%B9%A0%E7%BA%B2%E8%A6%81/"/>
    <url>/2022/06/09/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%A4%8D%E4%B9%A0%E7%BA%B2%E8%A6%81/</url>
    
    <content type="html"><![CDATA[<h1 id="一-引论"><a href="#一-引论" class="headerlink" title="一 引论"></a>一 引论</h1><h2 id="了解"><a href="#了解" class="headerlink" title="了解"></a>了解</h2><h3 id="1-2-为什么要进行软件测试"><a href="#1-2-为什么要进行软件测试" class="headerlink" title="1.2 为什么要进行软件测试"></a>1.2 为什么要进行软件测试</h3><ul><li>软件测试——产品质量的保证</li><li>软件测试——控制成本的关键</li><li>软件测试——软件可靠性确认</li><li>软件测试——让企业具备国际竞争的实力</li></ul><h3 id="1-3-什么是软件测试"><a href="#1-3-什么是软件测试" class="headerlink" title="1.3 什么是软件测试"></a>1.3 什么是软件测试</h3><ul><li><p>Bill Hetzel博士（正向思维的代表）：</p><ul><li>软件测试就是为程序能够按预期设想那样运行而建立足够的信心。</li><li>“软件测试是一系列活动以评价一个程序或系统的特性或能力并确定是否达到预期的结果”</li><li>测试是为了验证软件是否符合用户需求，即验证软件产品是否能正常工作</li></ul></li><li><p>Glenford J. Myers （反向思维的代表）：</p><ul><li>测试是为了证明程序有错，而不是证明程序无错误</li><li>一个好的测试用例是在于它能发现至今未发现的错误 </li><li>一个成功的测试是发现了至今未发现的错误的测试 </li></ul></li><li><p>软件测试是由“验证（Verification）”和“有效性确认（Validation）”活动构成的整体</p><ul><li>验证”是检验软件是否已正确地实现了产品规格书所定义的系统功能和特性</li><li>“有效性确认”是确认所开发的软件是否满足用户真正需求的活动。</li></ul></li></ul><h3 id="1-4-软件测试和软件开发的关系"><a href="#1-4-软件测试和软件开发的关系" class="headerlink" title="1.4 软件测试和软件开发的关系"></a>1.4 软件测试和软件开发的关系</h3><p><img src="%E7%80%91%E5%B8%83%E6%A8%A1%E5%9E%8B.png" alt="让人误解的瀑布模型"></p><p><img src="W%E6%A8%A1%E5%9E%8B.png" alt="让人正解的W模型"></p><ol><li>测试过程和开发过程是同时开始的，同时结束的，两者保持同步的关系。</li><li>测试过程是对开发过程中阶段性成果和最终的产品进行验证的过程，所以两者相互依赖。前期，测试过程更多地依赖于开发过程；后期，开发过程更多地依赖于测试过程。</li><li>测试过程中的工作重点和开发工作的重点，可能是不一样的，两者有各自的特点。不论在资源管理方面，还是在风险管理方面，两者都存在差异。</li></ol><h3 id="1-5-软件测试和SQA的关系"><a href="#1-5-软件测试和SQA的关系" class="headerlink" title="1.5 软件测试和SQA的关系"></a>1.5 软件测试和SQA的关系</h3><ul><li>软件质量保证（Software Quality Assurance，SQA）活动是通过对软件产品有计划的进行评审和审计来验证软件是否合乎标准的系统工程，通过协调、审查和跟踪以获取有用信息，形成分析结果以指导软件过程。</li></ul><ol><li>SQA是一项管理工作，侧重于对流程的评审和监控</li><li>测试是一项技术性的工作，侧重对产品进行评估和验证</li><li>SQA指导、监督软件测试的计划和执行，督促测试工作的结果客观、准确和有效，并协助测试流程的改进</li><li>软件测试是SQA重要手段之一，为SQA提供所需的数据，作为质量评价的客观依据</li></ol><h3 id="1-6-软件测试的4种导向，5大学派"><a href="#1-6-软件测试的4种导向，5大学派" class="headerlink" title="1.6 软件测试的4种导向，5大学派"></a>1.6 软件测试的4种导向，5大学派</h3><ul><li>功能验证导向（正向思维）</li><li>破坏性检测导向（逆向思维）</li><li>质量评估导向（测试是提供产品的评估和质量度量）</li><li>缺陷预防导向（展示软件符合设计要求，发现缺陷，预防缺陷）</li></ul><ol><li>分析学派：分析学派认为软件测试是严格的技术性的，这一派在学术界有很多支持者。</li><li>标准学派：标准学派认为软件测试是用于衡量进度的一种方式，强调成本度量和可重复的标准。</li><li>质量学派：质量学派强调过程，软件测试人员像警察一样审判开发人员，又像守门员一样保证质量。</li><li>上下文驱动学派：上下文驱动学派强调软件测试人的作用，寻找利益相关的BUG。</li><li>敏捷学派：敏捷学派使用软件测试来验证开发是否完成，强调自动化。</li></ol><h2 id="掌握（NULL）"><a href="#掌握（NULL）" class="headerlink" title="掌握（NULL）"></a>掌握（NULL）</h2><h1 id="二-软件测试的基本概念"><a href="#二-软件测试的基本概念" class="headerlink" title="二 软件测试的基本概念"></a>二 软件测试的基本概念</h1><h2 id="了解-1"><a href="#了解-1" class="headerlink" title="了解"></a>了解</h2><h3 id="2-1"><a href="#2-1" class="headerlink" title="2.1"></a>2.1</h3><h4 id="2-1-2-软件缺陷定义"><a href="#2-1-2-软件缺陷定义" class="headerlink" title="2.1.2 软件缺陷定义"></a>2.1.2 软件缺陷定义</h4><ul><li>从产品内部看，软件缺陷是软件产品开发或维护过程中所存在的错误、毛病等各种问题</li><li>从外部看，软件缺陷是系统所需要实现的某种功能的失效或违背</li></ul><h4 id="2-1-5-修复软件缺陷的代价"><a href="#2-1-5-修复软件缺陷的代价" class="headerlink" title="2.1.5 修复软件缺陷的代价"></a>2.1.5 修复软件缺陷的代价</h4><p><img src="%E7%BC%BA%E9%99%B7%E6%88%90%E6%9C%AC.png" alt="缺陷成本"></p><ul><li>在设计阶段就是它的3～6倍，在编程阶段是它的10倍，在内部测试阶段是它的20～40倍， </li><li>在外部测试阶段是它的30～70倍，而到了产品发布出去时，这个数字就是40～1000倍，修正错误的代价不是随时间线性增长，而几乎是呈指数增长的。</li></ul><p><strong>结束标准</strong></p><ul><li>用例全部测试</li><li>覆盖率达到标准</li><li>缺陷率达到标准</li><li>其他指标达到标准</li></ul><h2 id="掌握"><a href="#掌握" class="headerlink" title="掌握"></a>掌握</h2><h3 id="2-3-软件测试的分类"><a href="#2-3-软件测试的分类" class="headerlink" title="2.3 软件测试的分类"></a>2.3 软件测试的分类</h3><p><img src="%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%88%86%E7%B1%BB.png" alt="软件测试分类"></p><ul><li>按测试的对象或范围分类，如单元测试、文档测试、系统测试等</li><li>按测试目的分类，如功能测试、回归测试、性能测试、可靠性测试、安全性测试和兼容性测试等</li><li>根据测试过程中被测软件是否被执行，分为静态测试和动态测试</li><li>根据是否针对系统的内部结构和具体实现算法来完成测试，可分为白盒测试和黑盒测试</li></ul><blockquote><p><strong>静态测试</strong><br>静态测试就是静态分析,对模块的源代码进行研读,查找错误或收集一些度量数据,并不需要对代码进行编译和仿真运行。静态测试包括对软件产品的需求和设计规格说明书的评审、对程序代码的复审等。静态分析的查错和分析功能是其他方法所不能替代的，可以采用人工检测和计算机辅助静态分析手段进行检测,但越来越多地采用工具进行自动化分析。</p></blockquote><blockquote><p><strong>动态测试</strong><br>动态测试是通过真正运行程序发现错误,通过观察代码运行过程,来获取系统行为、变量实时结果,内存、堆栈﹑线程以及测试覆盖度等各方面的信息,来判断系统是否存在问题﹐或者通过有效的测试用例,对应的输入输出关系来分析被测程序的运行情况,来发现缺陷。</p></blockquote><blockquote><p><strong>回归测试</strong><br>回归测试(regression testing):为保证软件中新的变化(新增加的代码、代码修改等)不会对原有功能的正常使用有影响而进行的测试。也就是说,满足用户需求的原有功能不应该因为代码变化而出现任何新的问题。</p></blockquote><blockquote><p><strong>压力测试</strong><br>压力测试(stress testing),也称负载测试(ioad testing):用来检查系统在不同负载(如数据量、并发用户、连接数等)条件下的系统运行情况,特别是高负载、极限负载下的系统运行情况,以发现系统不稳定,系统性能瓶颈,内存泄漏、CPU使用率过高等问题。</p></blockquote><h3 id="2-4-ST-ET"><a href="#2-4-ST-ET" class="headerlink" title="2.4 ST/ET"></a>2.4 ST/ET</h3><ul><li>Scripted Testing(ST) 基于脚本的测试<ul><li> 先设计后执行</li><li> Script: 手工测试的Test case 或者说 自动化的Test Script </li><li> 阶段性明显，属于较传统的测试方式（分析-&gt;设计-&gt;执行-&gt;报告）</li></ul></li><li>Exploratory Testing(ET) 探索式测试<ul><li>开发人员多、测试人员少，测试更关注效率</li><li>整个开发节奏很快，测试要跟上这个节奏</li><li>测试时间很少，需要快速完成测试</li><li>对产品或业务不够熟悉，需要操作或使用它来熟悉</li><li>产品某些部分复杂，需要不断探索，才能很好地完成测试</li></ul></li></ul><h4 id="ST-vs-ET"><a href="#ST-vs-ET" class="headerlink" title="ST vs. ET"></a>ST vs. ET</h4><table><thead><tr><th>ST</th><th>ET</th></tr></thead><tbody><tr><td>系统性强</td><td>高效率（个人能力强）</td></tr><tr><td>容易管理（可视性强）</td><td>适应性强</td></tr><tr><td>设计在先、执行在后</td><td>执行和思考并行</td></tr><tr><td>验证自己的思路</td><td>不断问系统</td></tr><tr><td>可预见性</td><td>学习的过程</td></tr><tr><td>强调逻辑分析</td><td>上下文驱动</td></tr><tr><td>关注需求和测试文档</td><td>强调个人能力</td></tr><tr><td>有明确的测试标准</td><td>Test Oracle</td></tr><tr><td>强调评审、可控</td><td>关注与产品的交互</td></tr><tr><td>严谨、规范</td><td>拥抱变化、乐趣</td></tr></tbody></table><h3 id="2-5-软件测试的工作范畴"><a href="#2-5-软件测试的工作范畴" class="headerlink" title="2.5 软件测试的工作范畴"></a>2.5 软件测试的工作范畴</h3><ul><li>软件测试工作的组织与管理：制定测试策略、测试计划，确认所采用的测试方法与规范，控制测试进度，管理测试资源。</li><li>测试工作的实施：编制符合标准的测试文档，搭建测试环境，开发测试脚本、与开发组织协作实现各阶段的测试活动 </li></ul><h1 id="三-软件测试方法"><a href="#三-软件测试方法" class="headerlink" title="三 软件测试方法"></a>三 软件测试方法</h1><h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><h3 id="白盒测试的概念"><a href="#白盒测试的概念" class="headerlink" title="白盒测试的概念"></a>白盒测试的概念</h3><p>白盒测试也称结构测试或逻辑驱动测试，它是按照程序内部的结构测试程序，通过测试来检测产品内部动作是否按照设计规格说明书的规定正常进行，检验程序中的每条通路是否都能按预定要求正确工作。</p><h3 id="黒盒测试的概念"><a href="#黒盒测试的概念" class="headerlink" title="黒盒测试的概念"></a>黒盒测试的概念</h3><p>黑盒测试也称功能测试，它是通过测试来检测每个功能是否都能正常使用。在测试中，把程序看作一个不能打开的黑盒子，在完全不考虑程序内部结构和内部特性的情况下，在程序接口进行测试，它只检查程序功能是否按照需求规格说明书的规定正常使用，程序是否能适当地接收输入数据而产生正确的输出信息。黑盒测试着眼于程序外部结构，不考虑内部逻辑结构，主要针对软件界面和软件功能进行测试。</p><h3 id="什么是测试用例"><a href="#什么是测试用例" class="headerlink" title="什么是测试用例"></a>什么是测试用例</h3><p>为某个特殊目标而编制的一组测试输入、执行条件以及预期结果，以便测试某个程序路径或核实是否满足某个特定需求。指对一项特定的软件产品进行测试任务的描述，体现测试方案、方法、技术和策略。内容包括测试目标、测试环境、输入数据、测试步骤、预期结果、测试脚本等，并形成文档。</p><h3 id="为什么要设计测试用例"><a href="#为什么要设计测试用例" class="headerlink" title="为什么要设计测试用例"></a>为什么要设计测试用例</h3><ul><li>测试用例构成了设计和制定测试过程的基础。</li><li>测试的“深度”与测试用例的数量成比例。由于每个测试用例反映不同的场景、条件或经由产品的事件流，因而，随着测试用例数量的增加，对产品质量和测试流程也就越有信心。判断测试是否完全的一个主要评测方法是基于需求的覆盖，而这又是以确定、实施和/或执行的测试用例的数量为依据的。</li><li>测试工作量与测试用例的数量成比例。根据全面且细化的测试用例，可以更准确地估计测试周期各连续阶段的时间安排。</li><li>测试设计和开发的类型以及所需的资源主要都受控于测试用例。</li><li>测试用例通常根据它们所关联关系的测试类型或测试需求来分类，而且将随类型和需求进行相应地改变。最佳方案是为每个测试需求至少编制两个测试用例：<ul><li>一个测试用例用于证明该需求已经满足，通常称作正面测试用例</li><li>另一个测试用例反映某个无法接受、反常或意外的条件或数据，用于论证只有在所需条件下才能够满足该需求，这个测试用例称作负面测试用例</li></ul></li><li>测试用例是软件测试的核心</li></ul><h2 id="掌握-1"><a href="#掌握-1" class="headerlink" title="掌握"></a>掌握</h2><h3 id="白盒测试方法的分类（用条件覆盖法设计白盒测试用例）"><a href="#白盒测试方法的分类（用条件覆盖法设计白盒测试用例）" class="headerlink" title="白盒测试方法的分类（用条件覆盖法设计白盒测试用例）"></a>白盒测试方法的分类（用条件覆盖法设计白盒测试用例）</h3><ul><li><strong>语句覆盖</strong>，语句覆盖法的基本思想是设计若干测试用例，运行被测程序，使程序中的每个可执行语句至少被执行一次</li><li><strong>判定覆盖</strong>，判定覆盖法的基本思想是设计若干用例，运行被测程序，使得程序中每个判断的取真分支和取假分支至少经历一次，即判断真假值均曾被满足</li><li><strong>条件覆盖</strong>，条件覆盖的基本思想是设计若干测试用例，执行被测程序以后，要使每个判断中每个条件的可能取值至少满足一次。</li><li>判定-条件覆盖，是判定和条件覆盖设计方法的交集，即设计足够的测试用例，使得判断条件中的所有条件可能取值至少执行一次，同时，所有判断的可能结果至少执行一次</li><li>条件组合覆盖，设计足够的测试用例，使得判断中每个条件的所有可能至少出现一次，并且每个判断本身的判定结果也至少出现一次(它与条件覆盖的差别是它不是简单地要求每个条件都出现“真”与“假”两种结果，而是要求让这些结果的所有可能组合,指的是一个判断中的所有条件的组合都至少出现一次)</li><li>路径覆盖，设计所有的测试用例，来覆盖程序中的所有可能的执行路径。</li></ul><p><img src="%E9%80%BB%E8%BE%91%E8%A6%86%E7%9B%96%E5%85%B3%E7%B3%BB.png" alt="逻辑覆盖关系"></p><h4 id="基本路径测试法"><a href="#基本路径测试法" class="headerlink" title="基本路径测试法"></a>基本路径测试法</h4><ul><li><p>环路复杂度的3种方法：</p><ol><li>$V(G) = 区域数量(由节点、连线包围的区域，包括图形外部区域)$</li><li>$V(G) = 连线数量 - 节点数量 + 2$</li><li>$V(G) = 简单可预测节点数量 + 1$</li></ol></li><li><p>为什么需要求环路复杂度</p><ul><li>代码逻辑复杂度的度量，提供了被测代码的路径数量。复杂度越高，出错的概率越大</li></ul></li><li><p>构造基本路径集合的方法</p><ol><li>依据代码绘制流程图</li><li>确定流程图的圈复杂度</li><li>确定线性独立路径的基本集合</li><li>设计测试用例覆盖每条基本路径<br><img src="%E5%9F%BA%E6%9C%AC%E8%B7%AF%E5%BE%84.png" alt="基本路径"></li></ol></li><li><p>独立路径： 至少引入一系列新的处理语句或条件的任何路径</p></li><li><p>基本集： 由独立路径构成的集合</p></li><li><p>由基本集导出的测试用例，保证每行代码语句至少被执行一次</p></li><li><p>基本集合不一定唯一</p></li></ul><h3 id="黑盒测试方法的分类（用等价类和边界值设计黒盒测试用例）"><a href="#黑盒测试方法的分类（用等价类和边界值设计黒盒测试用例）" class="headerlink" title="黑盒测试方法的分类（用等价类和边界值设计黒盒测试用例）"></a>黑盒测试方法的分类（用等价类和边界值设计黒盒测试用例）</h3><h4 id="等价类划分法"><a href="#等价类划分法" class="headerlink" title="等价类划分法"></a>等价类划分法</h4><p>等价类划分法（等价分类法），分为有效等价类和无效等价类。有效等价类是有意义的、合理的输入数据，可检查程序是否实现了规格说明中所规定的功能和性能。无效等价类与有效等价类的意义相反</p><ul><li>等价类是某个输入域的子集，在该子集中每个输入数据的作用是等效的</li><li>将输入数据分成若干个子集，从每个子集选取一个代表性的数据作为测试用例</li><li>在分析需求规格说明的基础上划分等价类，列出等价类表</li></ul><ol><li>在输入条件规定了取值范围或值的个数的情况下，则可以确立一个有效等价类和两个无效等价类</li><li>在输入条件规定了输入值的集合或者规定了“必须如何”的条件的情况下，可以确立一个有效等价类和一个无效等价类</li><li>在输入条件是一个布尔量的情况下，可确定一个有效等价类和一个无效等价类</li><li>在规定了输入数据的一组值(假定n个)，并且程序要对每一个输入值分别处理的情况下，可确立n个有效等价类和一个无效等价类</li><li>在规定了输入数据必须遵守的规则的情况下，可确立一个有效等价类(符合规则)和若干个无效等价类(从不同角度违反规则)</li></ol><ul><li><p>等价类创建测试用例步骤</p><ol><li>建立等价类表，列出所有划分的等价类<table><thead><tr><th>输入条件</th><th>有效等价类</th><th>无效等价类</th></tr></thead><tbody><tr><td>…</td><td>…</td><td>…</td></tr></tbody></table></li><li>为每个等价类规定一个唯一的编号</li><li>设计一个新的测试用例，使其尽可能多地覆盖尚未覆盖的有效等价类</li><li>重复第三步，直至所有的有效等价类均被测试用例覆盖</li><li>设计一个新的测试用例，使其只覆盖一个无效等价类</li><li>重复第五步，直至所有的无效等价类均被测试用例覆盖</li></ol></li><li><p>这里可以加个例题</p></li></ul><h4 id="边界值分析法"><a href="#边界值分析法" class="headerlink" title="边界值分析法"></a>边界值分析法</h4><ul><li>确定边界情况（输入或输出等价类的边界）</li><li>选取正好等于、刚刚大于或刚刚小于边界值作为测试数据</li></ul><h4 id="因果图法"><a href="#因果图法" class="headerlink" title="因果图法"></a>因果图法</h4><ul><li>多种输入条件的组合，产生多种结果设计测试用例</li><li>设计方法：<ul><li>分析软件规格说明文档描述的哪些是原因（输入条件），哪些是结果（输出条件），给每个原因和结果赋予一个标示符</li><li>找出原因与结果，原因与原因之间的对应关系，划出因果图</li><li>在因果图上标上哪些不可能发生的因果关系，表明约束或限制条件</li><li>根据因果图，创建判定表，将复杂的逻辑关系和多种条件组合很具体明确的表示出来</li><li>把判定表的每一行作为依据设计测试用例</li></ul></li></ul><p><img src="%E5%9B%A0%E6%9E%9C%E5%9B%BE%E5%9F%BA%E6%9C%AC.png" alt="因果图基本"></p><h4 id="判定表法！！！"><a href="#判定表法！！！" class="headerlink" title="判定表法！！！"></a>判定表法！！！</h4><ul><li>在实际应用中，许多输入是由多个因素构成，而不是单一因素，这时就需要多因素组合分析</li><li>对于多因素，有时可以直接对输入条件进行组合设计，不需要进行因果分析，即直接采用判定表方法。</li><li>判定表由“条件和活动”两部分组成，即列出一个测试活动执行所需的条件组合，所有可能的条件组合定义了一系列的选择，而测试活动需要考虑每一个选择。</li><li>判定表构成元素<ul><li>条件桩，列出问题的所有条件</li><li>动作桩，列出可能针对问题采取的操作</li><li>动作项，列出在条件项（各种取值）组合情况下应该采取的动作</li><li>条件项，针对所列条件的具体赋值</li><li>规则 ，任何一个条件组合的特定取值及其相应要执行的操作</li></ul></li><li>方法步骤<ol><li>列出条件桩</li><li>列出动作桩</li><li>填入条件项及其组合</li><li>填入动作项，制定初始判定表</li><li>简化、合并相似规则或者相同动作</li></ol></li></ul><p><img src="%E5%88%A4%E5%AE%9A%E8%A1%A81.png" alt="判定表1"></p><h4 id="杂类"><a href="#杂类" class="headerlink" title="杂类"></a>杂类</h4><ul><li>有限自动机</li><li>堆栈的</li><li>状态图</li><li>状态表</li><li>状态转化树</li></ul><h1 id="四"><a href="#四" class="headerlink" title="四"></a>四</h1><h2 id="了解-2"><a href="#了解-2" class="headerlink" title="了解"></a>了解</h2><ul><li>TMMi，过程能力描述了遵循一个软件测试过程可能达到的预期结果的范围。TMM的建立，得益于以下3点：<ul><li>充分吸收CMM/CMMi的精华；</li><li>基于历史演化的测试过程；</li><li>业界的最佳实践。</li></ul></li><li>TPI， TPI是基于连续性表示法的测试过程改进的参考模型，是在软件控制、测试知识以及过往经验的基础上开发出来的</li><li>CTP,关键测试过程（Critical Test Process，CTP）评估模型主要是一个内容参考模型，一个上下文相关的方法，并能对模型进行裁剪</li><li>STEP（Systematic Test and Evaluation Process，系统化测试和评估过程）是一个内容参考模型，认定测试是一个生命周期活动，在明确需求后开始直到系统退役。</li></ul><h2 id="掌握-NULL"><a href="#掌握-NULL" class="headerlink" title="掌握(NULL)"></a>掌握(NULL)</h2><h1 id="五-单元测试"><a href="#五-单元测试" class="headerlink" title="五 单元测试"></a>五 单元测试</h1><h2 id="了解-NULL"><a href="#了解-NULL" class="headerlink" title="了解(NULL)"></a>了解(NULL)</h2><h2 id="掌握-2"><a href="#掌握-2" class="headerlink" title="掌握"></a>掌握</h2><h3 id="单元测试的概念"><a href="#单元测试的概念" class="headerlink" title="单元测试的概念"></a>单元测试的概念</h3><ul><li>定义：单元测试是对软件基本组成单元（如函数、类的方法等）进行的测试。</li><li>时机：一般在代码完成后由开发人员完成,QA人员辅助。</li><li>概念：模块, 组件, 单元。</li><li>单元测试的测试人员： 程序人员和开发人员</li><li>单元测试的测试方法<ul><li>检查每一条独立执行路径的测试。保证每条语句被至少执行一次。</li><li>检查局部数据结构完整性</li><li>检查模块接口是否正确</li><li>检查临界数据处理的正确性</li><li>预见、预设的各种出错处理是否正确有效</li></ul></li><li>单元测试的测试依据：详细设计和概要设计<ul><li>单元测试是对软件基本组成单元进行测试。依据是：软件详细说明书。</li><li>单元测试测试的不仅仅是代码，有：接口测试、局部数据结构测试、独立路径测试、边界条件测试、错误处理测试、功能测试、性能测试、内存使用测试等。</li></ul></li></ul><h3 id="单元测试的主要目标"><a href="#单元测试的主要目标" class="headerlink" title="单元测试的主要目标"></a>单元测试的主要目标</h3><ul><li>单元模块被正确编码</li><li>信息能否正确地流入和流出单元；</li><li>在单元工作过程中，其内部数据能否保持其完整性，包括内部数据的形式、内容及相互关系不发生错误，也包括全局变量在单元中的处理和影响。 </li><li>在为限制数据加工而设置的边界处，能否正确工作。</li><li>单元的运行能否做到满足特定的逻辑覆盖。 </li><li>单元中发生了错误，其中的出错处理措施是否有效。</li></ul><h1 id="六-集成测试和系统测试"><a href="#六-集成测试和系统测试" class="headerlink" title="六 集成测试和系统测试"></a>六 集成测试和系统测试</h1><h2 id="了解（NULL）"><a href="#了解（NULL）" class="headerlink" title="了解（NULL）"></a>了解（NULL）</h2><h2 id="掌握-3"><a href="#掌握-3" class="headerlink" title="掌握"></a>掌握</h2><h3 id="集成测试的概念"><a href="#集成测试的概念" class="headerlink" title="集成测试的概念"></a>集成测试的概念</h3><ul><li><p>定义：集成测试是将软件集成起来，对模块之间的接口进行测试。顾名思义，集成测试是将软件集成起来后进行测试。集成测试又叫子系统测试、组装测试、部件测试等。</p><ol><li>模块内的集成，主要是测试模块内各个接口间的交互集成关系；</li><li>子系统内的集成，测试子系统内各个模块间的交互关系；</li><li>系统内的集成，测试系统内各个子系统和模块间的集成关系；</li></ol></li><li><p>集成测试的测试人员：有经验的测试人员和开发者共同</p></li><li><p>集成测试的集成模式和经典代表</p><ol><li>非渐增式测试模式：先分别测试每个模块，再把所有模块按设计要求放在一起结合成所要的程序，如大棒模式。</li><li>渐增式测试模式：把下一个要测试的模块同已经测试好的模块结合进来进行测试，测试完后再把下一个应该测试的模块结合起来测试。渐增式测试又可以根据每次添加模块的路线分为自顶向下测试、自底向上测试和混合测试等方式。</li></ol></li><li><p>测试依据：概要设计书，详细设计说明书，主要是概要设计说明书</p></li></ul><h3 id="集成测试的主要目标"><a href="#集成测试的主要目标" class="headerlink" title="集成测试的主要目标"></a>集成测试的主要目标</h3><p>集成测试，也叫组装测试或联合测试。在单元测试的基础上，将所有模块按照设计要求（如根据结构图）组装成为子系统或系统，进行集成测试。实践表明，一些模块虽然能够单独地工作，但并不能保证连接起来也能正常的工作。程序在某些局部反映不出来的问题，在全局上很可能暴露出来，影响功能的实现。</p><p>目标在于检验与软件设计相关的程序结构问题。如数据穿过接口时可能丢失；一个模块与另一个模块可能有由于疏忽的问题而造成有害影响； 把子功能组合起来可能不产生预期的主功能；个别看起来是可以接受的误差可能积累到不能接受的程度；全程数据结构可能有错误等。</p><h3 id="驱动程序与桩程序"><a href="#驱动程序与桩程序" class="headerlink" title="驱动程序与桩程序"></a>驱动程序与桩程序</h3><ul><li><p>驱动程序</p><p>对底层或子层模块进行测试所编写的，调用这些模块的程序。</p></li><li><p>桩程序</p><p>对顶层或上层模块进行测试时所编写的，替代下层模块的程序。</p></li></ul><p><img src="%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E5%92%8C%E6%A1%A9%E7%A8%8B%E5%BA%8F.png" alt="驱动程序和桩程序"></p><h3 id="系统测试的概念"><a href="#系统测试的概念" class="headerlink" title="系统测试的概念"></a>系统测试的概念</h3><ul><li><p>定义：检验系统所有元素之间协作是否合适，整个系统的性能和功能是否达到要求。其测试内容包括：功能测试，非功能测试与回归测试等。</p></li><li><p>系统测试的测试人员：软件测试工程师</p></li><li><p>系统测试的内容：功能测试、非功能测试、回归测试。</p></li><li><p>非功能测试主要包括：性能测试、压力测试、容量测试、安全性测试、可靠性测试、容错性测试。</p></li><li><p>测试依据：需求说明书，概要设计说明书，详细设计说明书，最重要的是需求说明书。</p></li></ul><h3 id="确认测试"><a href="#确认测试" class="headerlink" title="确认测试"></a>确认测试</h3><p>确认测试又称有效性测试。有效性测试是在模拟的环境下，运用黑盒测试的方法，验证被测软件是否满足需求规格说明书列出的需求。任务是验证软件的功能和性能及其他特性是否与用户的要求一致。对软件的功能和性能要求在软件需求规格说明书中已经明确规定，它包含的信息就是软件确认测试的基础。</p><h1 id="七-验收测试和测试用例"><a href="#七-验收测试和测试用例" class="headerlink" title="七 验收测试和测试用例"></a>七 验收测试和测试用例</h1><h2 id="了解（NULL）-1"><a href="#了解（NULL）-1" class="headerlink" title="了解（NULL）"></a>了解（NULL）</h2><h2 id="掌握-4"><a href="#掌握-4" class="headerlink" title="掌握"></a>掌握</h2><h3 id="验收测试的概念"><a href="#验收测试的概念" class="headerlink" title="验收测试的概念"></a>验收测试的概念</h3><ul><li>定义：检查软件是否符合合同要求，包括需求规格说明、设计规格说明和用户手册等。</li><li>测试内容包括：<ol><li>易用性测试（用户界面和可用性测试）；</li><li>兼容性测试（软件兼容性测试、数据共享兼容性测试、硬件兼容性测试）；</li><li>安装测试和可恢复性测试、文档测试等（安装与卸载测试、可恢复性测试）；</li><li>验收测试的内容（正确性、完备性、易理解性、一致性）；</li></ol></li><li>验收测试的测试人员：用户和测试部门共同完成。</li><li>测试依据：国家规范、行业标准、合同条款、用户确认的需求规格说明书。</li></ul><h3 id="α，β测试"><a href="#α，β测试" class="headerlink" title="α，β测试"></a>α，β测试</h3><p>α测试是指软件开发公司组织内部人员模拟各类用户行对即将面市软件产品（称为α版本）进行测试，试图发现错误并修正。</p><p>经过α测试调整的软件产品称为β版本。紧随其后的β测试是指软件开发公司组织各方面的典型用户在日常工作中实际使用β版本，并要求用户报告异常情况、提出批评意见。然后软件开发公司再对β版本进行改错和完善。</p><h1 id="八-软件本地化测试"><a href="#八-软件本地化测试" class="headerlink" title="八 软件本地化测试"></a>八 软件本地化测试</h1><h3 id="I18N"><a href="#I18N" class="headerlink" title="I18N"></a>I18N</h3><p>国际化是借助功能设计和代码实现中软件系统有能力处理多种语言和不同文化，使创建不同语言版本时，不需要重新编写代码的软件工程方法。</p><h3 id="L10N"><a href="#L10N" class="headerlink" title="L10N"></a>L10N</h3><p>L10N是将一个软件产品按特定国家/地区或语言市场的需要进行加工，使之满足特定市场上的用户对语言和文化的特殊要求的软件生产活动。</p><h3 id="G11N"><a href="#G11N" class="headerlink" title="G11N"></a>G11N</h3><p>全球化是一个概念化产品的过程，它基于全球市场考虑，以便一个产品只做较小的改动就可以在世界各地出售。全球化可以看作国际化和本地化两者合成的结果。</p><h3 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h3><p>软件本地化和软件国际化的关系是一个辩证的关系，本地化要适应国际化的规定。而国际化是本地化的基础和前提，为本地化做准备，使本地化过程不需要对代码做改动就能完成，或将代码修改降到最低限度。</p><p><strong>G11N = I18N + L10N</strong></p><p><img src="%E5%9B%BD%E9%99%85%E5%8C%96-%E6%9C%AC%E5%9C%B0%E5%8C%96-%E5%85%A8%E7%90%83%E5%8C%96%E5%85%B3%E7%B3%BB.png" alt="国际化-本地化-全球化关系"></p><h2 id="了解-3"><a href="#了解-3" class="headerlink" title="了解"></a>了解</h2><h2 id="掌握-5"><a href="#掌握-5" class="headerlink" title="掌握"></a>掌握</h2><h1 id="九-软件测试自动化"><a href="#九-软件测试自动化" class="headerlink" title="九 软件测试自动化"></a>九 软件测试自动化</h1><h2 id="了解-4"><a href="#了解-4" class="headerlink" title="了解"></a>了解</h2><ul><li><p>功能测试工具：QTP</p></li><li><p>性能测试工具：LoadRunner</p></li></ul><h2 id="掌握-6"><a href="#掌握-6" class="headerlink" title="掌握"></a>掌握</h2><h3 id="测试自动化的内涵"><a href="#测试自动化的内涵" class="headerlink" title="测试自动化的内涵"></a>测试自动化的内涵</h3><ul><li>定义：自动化测试（automated test）是相对手工测试而存在的一个概念，由手工逐个地运行测试用例的操作过程被测试工具自动执行的过程所代替。</li><li>测试工具的使用是自动化测试的主要特征：测试自动化指“一切可以由计算机系统自动完成的测试任务都已经由计算机系统或软件工具、程序来承担并自动执行” </li><li>测试自动化实现的原理<ol><li>代码分析:类似于高级编译系统，在工具中定义类/对象/函数/变量等定义规则、语法规则等，在分析时对代码进行语法扫描，找出不符合编码规范的地方。</li><li>对象识别  （Windows对象、Mac对象、Web DOM对象）</li><li>脚本技术：线性脚本 结构化脚本 数据驱动脚本、关键字驱动脚本</li><li>自动比较技术：静态比较和动态比较，简单比较和复杂比较，敏感性测试比较和健壮性测试比较，比较过滤器</li><li>测试自动化系统的构成：测试工具的分类、测试工具的选择、测试自动化普遍存在的问题、自动化测试的引入和应用 自动化测试的引入和应用<ul><li>找准测试自动化的切入点</li><li>把测试开发纳入整个软件开发体系</li><li>测试自动化依赖测试流程和测试用例</li><li>软件测试自动化的投入较大</li><li>进行资源的合理调度</li></ul></li></ol></li></ul><h3 id="自动化测试框架"><a href="#自动化测试框架" class="headerlink" title="自动化测试框架"></a>自动化测试框架</h3><p><img src="%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6.png" alt="自动化测试框架"></p>]]></content>
    
    
    <categories>
      
      <category>复习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1038 Recover the Smallest Number</title>
    <link href="/2022/05/24/1038-Recover-the-Smallest-Number/"/>
    <url>/2022/05/24/1038-Recover-the-Smallest-Number/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>Given a collection of number segments, you are supposed to recover the smallest number from them. For example, given { 32, 321, 3214, 0229, 87 }, we can recover many numbers such like 32-321-3214-0229-87 or 0229-32-87-321-3214 with respect to different orders of combinations of these segments, and the smallest number is 0229-321-3214-32-87.</p><h1 id="贪心思路"><a href="#贪心思路" class="headerlink" title="贪心思路"></a>贪心思路</h1><p>每次选择最小的数字排在前面，这样最终得到的数字就是最小的。<br>比如 1，2，3，4，5，6，7，8要组成最小的数字，那就是12345678。<br>但这个题目显然比单一最小更复杂，单纯的利用数字大小或者字符串的字典序大小都是不可行的。<br>那么如何判断一个数字字符串“小于”另一个数字字符串呢？<br>我们不妨设一个数字字符串为a,另一个数字字符串为b。<br>那么，它们可以组成ab和ba两种形式的数字字符串，这样组成的数字字符串一定是等长的，也就意味着大小是可以通过字典序来比较的。<br>因此，如果ab &lt; ba,则说明 a 要 “小于” b，反之，则 b 要 “小于” a。<br>自此，我们就从逻辑上解决了这个问题。</p><h1 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">10010</span>;<br><br>string s[N];<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;a,<span class="hljs-type">const</span> string &amp;b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> a + b &lt; b + a;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n; ++ i)<br>    &#123;<br>        cin&gt;&gt;s[i];<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(s,s + n,cmp);<br>    string res;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++ i)<br>    &#123;<br>        res += s[i];<br>    &#125;<br>    <span class="hljs-keyword">while</span>(res.<span class="hljs-built_in">size</span>() &amp;&amp; res[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;0&#x27;</span>)<br>    &#123;<br>        res.<span class="hljs-built_in">erase</span>(res.<span class="hljs-built_in">begin</span>());<br>    &#125;<br>    <span class="hljs-keyword">if</span>(res.<span class="hljs-built_in">size</span>())<br>    &#123;<br>        cout&lt;&lt;res;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        cout&lt;&lt;<span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PAT甲级</category>
      
    </categories>
    
    
    <tags>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1033 To Fill or Not to Fill</title>
    <link href="/2022/05/21/1033-To-Fill-or-Not-to-Fill/"/>
    <url>/2022/05/21/1033-To-Fill-or-Not-to-Fill/</url>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>With highways available, driving a car from Hangzhou to any other city is easy. But since the tank capacity of a car is limited, we have to find gas stations on the way from time to time. Different gas station may give different price. You are asked to carefully design the cheapest route to go.</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><h1 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PAT甲级</category>
      
    </categories>
    
    
    <tags>
      
      <tag>贪心算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>测试</title>
    <link href="/2022/05/21/%E6%B5%8B%E8%AF%95/"/>
    <url>/2022/05/21/%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<p>第一篇测试博客</p><img src="/2022/05/21/%E6%B5%8B%E8%AF%95/first.png" class="" title="图片引用方法一"><p><img src="first.png" alt="图片引用方法二"></p>]]></content>
    
    
    <categories>
      
      <category>test</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/05/21/hello-world/"/>
    <url>/2022/05/21/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
